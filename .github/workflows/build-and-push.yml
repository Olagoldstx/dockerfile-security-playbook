name: Build, Scan, Push, and Sign (ECR)

on:
  push:
    branches: [ main ]
  pull_request:

permissions:
  contents: read

env:
  APP_DIR: apps/api-python-flask     # path containing the Dockerfile
  IMAGE_TAG: latest                  # also tags with the commit SHA

jobs:
  build-scan-push-sign:
    runs-on: ubuntu-latest

    # Make critical values available to every step
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPO_URI: ${{ secrets.ECR_REPO_URI }}
      AWS_KMS_KEY_ARN: ${{ secrets.AWS_KMS_KEY_ARN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (access keys for now)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # ── Normalize and verify ECR_REPO_URI ──────────────────────────────────────
      - name: Normalize ECR_REPO_URI
        run: |
          CLEAN=$(printf %s "$ECR_REPO_URI" | tr -d '\r\n' | xargs)
          echo "ECR_REPO_URI_CLEAN=$CLEAN" >> "$GITHUB_ENV"

      - name: Show normalized value (debug)
        run: |
          echo "ECR_REPO_URI(raw)   ='$ECR_REPO_URI'"
          echo "ECR_REPO_URI(clean) ='$ECR_REPO_URI_CLEAN'"
          printf "LEN(raw)=%s\n"   "$(printf %s "$ECR_REPO_URI" | wc -c)"
          printf "LEN(clean)=%s\n" "$(printf %s "$ECR_REPO_URI_CLEAN" | wc -c)"
          test -n "$ECR_REPO_URI_CLEAN" || { echo "ECR_REPO_URI_CLEAN is empty"; exit 1; }

      # ── Build, scan, push ─────────────────────────────────────────────────────
      - name: Build image
        working-directory: ${{ env.APP_DIR }}
        run: |
          docker build -t "${ECR_REPO_URI_CLEAN}:${IMAGE_TAG}" .
          docker tag  "${ECR_REPO_URI_CLEAN}:${IMAGE_TAG}" "${ECR_REPO_URI_CLEAN}:${GITHUB_SHA}"

      - name: Trivy scan (fail on CRITICAL/HIGH)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.ECR_REPO_URI_CLEAN }}:${{ env.IMAGE_TAG }}
          format: 'table'
          exit-code: '1'
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true

      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh \
            | sh -s -- -b /usr/local/bin

      - name: Generate SBOM (CycloneDX JSON)
        run: |
          syft scan image:${ECR_REPO_URI_CLEAN}:${IMAGE_TAG} -o cyclonedx-json > sbom-${{ github.sha }}.json

      - name: Push image
        run: |
          docker push "${ECR_REPO_URI_CLEAN}:${IMAGE_TAG}"
          docker push "${ECR_REPO_URI_CLEAN}:${GITHUB_SHA}"

      # ── Sign by DIGEST (recommended) ──────────────────────────────────────────
      - name: Install Cosign
        run: |
          curl -sSfL https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64 \
            -o /usr/local/bin/cosign
          chmod +x /usr/local/bin/cosign

      - name: Resolve image digests
        id: dig
        run: |
          # Ensure local view of pushed images has RepoDigests populated
          docker pull "${ECR_REPO_URI_CLEAN}:${GITHUB_SHA}"
          docker pull "${ECR_REPO_URI_CLEAN}:${IMAGE_TAG}"
          SHA_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${ECR_REPO_URI_CLEAN}:${GITHUB_SHA}")
          LATEST_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${ECR_REPO_URI_CLEAN}:${IMAGE_TAG}")
          echo "sha=${SHA_DIGEST}" >> "$GITHUB_OUTPUT"
          echo "latest=${LATEST_DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Resolved SHA_DIGEST=${SHA_DIGEST}"
          echo "Resolved LATEST_DIGEST=${LATEST_DIGEST}"

            - name: Cosign sign (AWS KMS) by digest
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_YES: "true"
          # Use the KMS alias you created in Terraform
          KMS_KEY_URI: awskms:///alias/acme-cosign
        run: |
          # Sanity check: can we read the public key from KMS?
          cosign public-key --key "${KMS_KEY_URI}" >/dev/null
          echo "KMS public key is accessible."

          # Sign by digest (recommended)
          cosign sign --key "${KMS_KEY_URI}" "${{ steps.dig.outputs.sha }}"
          cosign sign --key "${KMS_KEY_URI}" "${{ steps.dig.outputs.latest }}"

